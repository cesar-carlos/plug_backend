import { app } from "./app";
import { configureSocket } from "./socket";
import { logger } from "./shared/utils/logger";
import { env } from "./shared/config/env";
import { container } from "./shared/di/container";
import { runMigrations } from "./infrastructure/database/migrations/migrate";
import { Database } from "./infrastructure/database/database";

const PORT = parseInt(env.PORT, 10);

const initializeDatabase = async (): Promise<void> => {
  try {
    // Run migrations (database connection will be created in Database singleton)
    await runMigrations();
    logger.info("Database initialized and migrations applied");
  } catch (err) {
    logger.error({ err }, "Failed to initialize database");
    throw err;
  }
};

const initializeAdminUser = async (): Promise<void> => {
  try {
    const defaultPassword = process.env.DEFAULT_ADMIN_PASSWORD;
    if (defaultPassword && container.userRepository.setUserPassword) {
      const hashedPassword = await container.passwordHasher.hash(
        defaultPassword
      );
      await container.userRepository.setUserPassword("admin", hashedPassword);
      logger.info("Admin user initialized");
    }
  } catch (err) {
    logger.error(
      { err },
      "Failed to initialize admin user - continuing without default admin"
    );
  }
};

try {
  await initializeDatabase();
  await initializeAdminUser();

  // Configura Socket.io ANTES de iniciar o servidor
  // NecessÃ¡rio para integrar corretamente com Bun usando bun-engine
  let socketConfig;
  try {
    socketConfig = configureSocket();
    logger.info("Socket.io server configured successfully");
  } catch (err) {
    logger.error(
      { err },
      "Failed to configure Socket.io - continuing without WebSocket"
    );
    socketConfig = undefined;
  }

  // Inicia o servidor Elysia com o engine do Socket.io
  // O engine.handler() fornece os handlers de WebSocket necessÃ¡rios para o Bun
  if (socketConfig) {
    app.listen({
      port: PORT,
      ...socketConfig.engine.handler(),
    });
  } else {
    app.listen(PORT);
  }

  // Verifica se o servidor foi inicializado corretamente
  if (!app.server) {
    logger.fatal("Failed to start server - app.server is undefined");
    process.exit(1);
  }

  const hostname = app.server.hostname || "0.0.0.0";
  const port = app.server.port || PORT;
  logger.info(
    `ðŸ¦Š Elysia is running at http://${hostname}:${port} (accessible via http://localhost:${port})`
  );
  
  // Armazena a configuraÃ§Ã£o do socket no Container para Dependency Injection
  if (socketConfig) {
    container.socketConfig = socketConfig;
  }
} catch (err) {
  logger.fatal({ err }, "Failed to start server");
  process.exit(1);
}

let isShuttingDown = false;

const gracefulShutdown = (signal: string): void => {
  if (isShuttingDown) {
    return;
  }
  isShuttingDown = true;

  logger.info(
    { signal },
    "Received shutdown signal, starting graceful shutdown"
  );

  try {
    Database.getInstance().close();
  } catch (err) {
    logger.error({ err }, "Error closing database connection");
  }

  setTimeout(() => {
    logger.fatal("Forced shutdown after timeout");
    process.exit(1);
  }, 10000);

  process.exit(0);
};

process.on("uncaughtException", (err: Error): void => {
  logger.fatal(
    { err, stack: err.stack },
    "Uncaught Exception - preventing crash"
  );
  gracefulShutdown("uncaughtException");
});

process.on(
  "unhandledRejection",
  (reason: unknown, promise: Promise<unknown>): void => {
    logger.error({ reason, promise }, "Unhandled Rejection - preventing crash");
  }
);

process.on("SIGTERM", () => gracefulShutdown("SIGTERM"));
process.on("SIGINT", () => gracefulShutdown("SIGINT"));
