---
alwaysApply: true
---

# TypeScript Best Practices & Coding Standards (2025-2026)

## 1. Core Principles & Strictness

### Enable Strict Mode

Always have `strict: true` in your `tsconfig.json`. This enables a wide range of type checking rules that catch errors early.

#### Core Strict Flags (enabled by `strict: true`)

- **`noImplicitAny`**: Prevents variables from implicitly inferring `any`.
- **`strictNullChecks`**: Makes strict distinction between `null`/`undefined` and other types.
- **`strictFunctionTypes`**: Enforces stricter checking for function parameter bivariance.
- **`strictBindCallApply`**: Strictly checks `bind`, `call`, and `apply` methods.
- **`strictPropertyInitialization`**: Ensures class properties are initialized.
- **`noImplicitThis`**: Prevents `this` from being implicitly typed as `any`.
- **`alwaysStrict`**: Enables strict mode for all emitted JavaScript.
- **`useUnknownInCatchVariables`**: Requires error handling in catch blocks to use `unknown`.

#### Additional Recommended Strict Flags

- **`exactOptionalPropertyTypes`**: Distinguishes between explicitly `undefined` and missing properties.
- **`noUncheckedIndexedAccess`**: Array/object access returns `T | undefined` instead of just `T`.
- **`noImplicitReturns`**: Warns when not all code paths return a value.
- **`noFallthroughCasesInSwitch`**: Prevents accidental fallthrough in switch cases.

#### Recommended tsconfig.json (2025)

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "useUnknownInCatchVariables": true,

    "exactOptionalPropertyTypes": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,

    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "incremental": true,
    "isolatedModules": true
  }
}
```

### Avoid `any`, Prefer `unknown`

- **Never use `any`**: It silently disables type checking and propagates lack of safety.
- **Use `unknown`**: If a value is truly dynamic, use `unknown`. It forces you to perform type checks (narrowing) before using the value.
- **Use generics** for reusable logic instead of `any`.

```typescript
// ❌ Bad
function process(data: any) {
  data.format(); // No error, but might crash
}

// ✅ Good
function process(data: unknown) {
  if (data instanceof String) {
    data.trim(); // Safe
  }
}

// ✅ Better: Use generics
function process<T extends string | number>(data: T) {
  return data.toString();
}
```

### Explicit Return Types

Always define return types for functions, especially exported ones. This prevents accidental return type changes and improves compiler performance.

```typescript
// ❌ Bad
export const getUser = (id: string) => db.users.find(id);

// ✅ Good
export const getUser = (id: string): Promise<User | null> => {
  return db.users.find(id);
};
```

## 2. Type System Utilization

### Interfaces vs Types

- **Use `interface`** for defining public API shapes and object structures (better error messages, extendable).
- **Use `type`** for unions, intersections, primitives, and complex utility types.
- **Prefer interfaces** for large object shapes (better optimization).

```typescript
// Object shape
interface User {
  id: string;
  name: string;
}

// Union
type Status = "pending" | "active" | "archived";

// Complex utility type
type PartialUser = Partial<User> & { readonly createdAt: Date };
```

### Immutability

Use `readonly` by default for array and object properties to prevent mutation side-effects.

```typescript
interface State {
  readonly id: string;
  readonly tags: readonly string[];
}

// Use as const for literal immutability
const config = {
  host: "localhost",
  port: 8080,
} as const;
```

### Branded Types (Opaque Types)

Use branded types to prevent mixing primitives that look similar, increasing safety.

```typescript
type UserId = string & { readonly __brand: unique symbol };
type Email = string & { readonly __brand: unique symbol };

function createUserId(id: string): UserId {
  return id as UserId;
}

function createUserEmail(email: string): Email {
  if (!email.includes("@")) {
    throw new Error("Invalid email");
  }
  return email as Email;
}

// This will cause a type error - prevents accidental mixing
// const userId: UserId = createUserEmail("test@test.com"); // ❌ Error
```

### Utility Types

Leverage built-in utilities to avoid duplication.

- `Pick<T, K>` / `Omit<T, K>`
- `Partial<T>` / `Required<T>`
- `Readonly<T>`
- `ReturnType<T>`
- `Parameters<T>`
- `Awaited<T>` (for Promise types)

## 3. Modern Patterns (2025+)

### The `satisfies` Operator

Use `satisfies` to validate a value matches a type _without_ widening the type (preserving literal inference).

```typescript
// ✅ Good
const config = {
  host: "localhost",
  port: 8080,
} satisfies Config;
// 'config.host' is typed as literal 'localhost', not string
```

### Template Literal Types

Use template literals for string patterns instead of generic strings.

```typescript
type EventName = `on${Capitalize<string>}`;
const handle: EventName = "onClick"; // ✅
const bad: EventName = "click"; // ❌ Error

// More practical example
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type ApiEndpoint<T extends string> = `/api/${T}`;

const endpoint: ApiEndpoint<"users"> = "/api/users"; // ✅
```

### Discriminated Unions

Use discriminated unions for handling different states or polymorphic data. This is the gold standard for state management (e.g., Redux, API states).

```typescript
type State =
  | { status: "loading" }
  | { status: "success"; data: User }
  | { status: "error"; error: Error };

function render(state: State) {
  if (state.status === "success") {
    // strict safe access to state.data
    console.log(state.data);
  }
}

// Use exhaustive matching with never
function handleState(state: State): string {
  switch (state.status) {
    case "loading":
      return "Loading...";
    case "success":
      return `Loaded: ${state.data.name}`;
    case "error":
      return `Error: ${state.error.message}`;
    default:
      const _exhaustive: never = state;
      return _exhaustive;
  }
}
```

### Result / Either Pattern for Error Handling

Use Result/Either pattern for type-safe error handling instead of exceptions for expected failures.

```typescript
type Result<T, E = Error> = { ok: true; value: T } | { ok: false; error: E };

// Helper functions
function ok<T>(value: T): Result<T> {
  return { ok: true, value };
}

function err<E>(error: E): Result<never, E> {
  return { ok: false, error };
}

// Usage
function fetchUser(id: string): Result<User, NotFoundError | ValidationError> {
  if (id === "") {
    return err(new ValidationError("ID must not be empty"));
  }
  if (id !== "42") {
    return err(new NotFoundError("User not found"));
  }
  return ok({ id, name: "Alice" });
}

// Handling
const result = fetchUser("42");
if (result.ok) {
  console.log("Success:", result.value.name);
} else {
  // Type-safe error handling
  if (result.error instanceof ValidationError) {
    console.error("Validation:", result.error.message);
  } else {
    console.error("Not found:", result.error.message);
  }
}
```

### Composition Over Inheritance

Favor small composable units (functions, hooks, services) rather than deep class hierarchies.

```typescript
// ❌ Bad: Deep inheritance
class BaseController {
  constructor(protected db: Database) {}
}

class UserController extends BaseController {
  getUser(id: string) {
    return this.db.find(id);
  }
}

class AdminController extends BaseController {
  // ... more code
}

// ✅ Good: Composition
interface Database {
  find(id: string): User;
}

function createUserController(db: Database) {
  return {
    getUser(id: string): Promise<User> {
      return db.find(id);
    },
    // ... other methods
  };
}
```

## 4. Performance & Type Inference (TS 5.9+)

### TypeScript 5.9 Performance Features

- **Cached Intermediate Type Instantiations**: Reduces redundant type checking for generic-heavy constructs.
- **Optimized File-Existence Checks**: ~11% speed improvement in projects with frequent file lookups.
- **Deferred Module Evaluation**: Use `import defer` to delay module initialization until needed.

```typescript
// Deferred import (TS 5.9)
import defer { heavyModule } from "./heavy";

// heavyModule only initializes when used
defer heavyModule;
```

### Performance Best Practices

1. **Provide explicit types at public API boundaries** - Helps compiler avoid inferring complex shapes.
2. **Simplify generics** - Don't over-generalize; use concrete types when possible.
3. **Reduce union/intersection complexity** - Limit the number of alternatives in unions.
4. **Leverage interfaces** - Better optimized than complex type aliases for large objects.
5. **Use `as const`** - For literal values to maintain precise types.
6. **Break large files** - Smaller modules improve caching and incremental builds.
7. **Enable `incremental: true`** - Caches compilation info for faster rebuilds.

### Compiler Configuration for Performance

```json
{
  "compilerOptions": {
    "incremental": true,
    "skipLibCheck": true,
    "isolatedModules": true,
    "composite": true
  }
}
```

## 5. Code Organization & Style

### Type-First API Design

The TypeScript source should be the canonical contract among teams. Types are versioned, documented, and used for code generation.

```typescript
// Define the contract first
interface ApiResponse<T> {
  data: T;
  meta: {
    timestamp: string;
    version: number;
  };
}

interface User {
  id: string;
  name: string;
  email: string;
}

// API uses the contract
async function fetchUser(id: string): Promise<ApiResponse<User>> {
  // implementation
}
```

### Naming Conventions

- **Types/Interfaces**: PascalCase (e.g., `UserResponse`). Do not prefix with `I` (e.g., `IUser` is outdated).
- **Variables/Functions**: camelCase.
- **Booleans**: Prefix with `is`, `has`, `should` (e.g., `isValid`, `hasAccess`).
- **Constants**: UPPER_SNAKE_CASE or camelCase depending on scope.

### Module Imports

- Prefer named exports over default exports for better refactoring support and tree-shaking.
- Use explicit type imports to clarify intent and help bundlers.

```typescript
import type { User } from "./types";
import { getUser } from "./api";

// Default exports are discouraged
// export default function getUser() { ... } // ❌

// Named exports are preferred
// export function getUser() { ... } // ✅
```

### Async/Await & Error Handling

- Always use `async`/`await` over raw `.then()`.
- Use custom Error classes or result types for predictable failure modes.
- Always catch with `unknown` and narrow the type.

```typescript
try {
  const data = await fetchData();
} catch (error: unknown) {
  if (error instanceof ApiError) {
    // handle specific error
  } else if (error instanceof NetworkError) {
    // handle network error
  } else {
    // handle unknown error
    console.error("Unexpected error:", error);
  }
}
```

## 6. Project Structure & Monorepo

### Monorepo Benefits

- Share types across packages
- Enforce consistency
- Optimize build/test pipelines
- Use tools like Nx or Turborepo for large projects

### Project References

Use project references to improve build times and type checking in large codebases.

```json
// tsconfig.base.json
{
  "files": [],
  "references": [
    { "path": "./packages/domain" },
    { "path": "./packages/application" },
    { "path": "./packages/infrastructure" }
  ]
}
```

## 7. Testing & Tooling

### Type Coverage

Use tools to measure how much of your codebase is strictly typed.

```bash
# Install type-coverage
npm install -D type-coverage

# Check type coverage
npx type-coverage
```

### Linting & Formatting

- **ESLint** with `@typescript-eslint` for linting
- **Prettier** for consistent formatting
- Enforce consistent code style and catch issues early

```bash
# Essential linting packages
npm install -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin prettier eslint-config-prettier
```

## 8. Migration Strategy

When enabling strict mode in existing codebases:

1. **Stage-by-stage enabling** - Start with critical flags like `strictNullChecks`, `noImplicitAny`.
2. **Use `@ts-ignore` / `@ts-expect-error` sparingly** - Only for high-cost refactoring.
3. **Split tsconfig files** - Separate configs for new and legacy code.
4. **Team training** - Ensure everyone understands why strictness matters.

### Dos and Don'ts Checklist

| Do                                                  | Don't                                     |
| --------------------------------------------------- | ----------------------------------------- |
| Prioritize type safety (strict modes, no `any`)     | Overcomplicate types where not needed     |
| Version and document API contracts                  | Break types without migration paths       |
| Adopt modular architectures & monorepos when needed | Use deep inheritance hierarchies          |
| Use modern tooling aligned with types               | Rely on JS-only tools                     |
| Provide explicit types at public API boundaries     | Rely on inference everywhere              |
| Use Result/Either for expected errors               | Use exceptions for everything             |
| Enable incremental builds                           | Rebuild everything from scratch           |
| Measure type coverage                               | Assume 100% coverage without verification |
